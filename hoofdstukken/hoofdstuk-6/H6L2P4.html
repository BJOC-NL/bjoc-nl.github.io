 <!DOCTYPE html>
 <html lang="nl">

 <head>
     <link rel="icon" href="../../BJOC-NL-logo.png" type="image/png">
     <meta http-equiv="content-type" content="text/html; charset=utf-8" />
     <script type="text/javascript" src="../../js+css/llab/loader.js"> </script>
     <script type="text/javascript" src="../../js+css/gifffer.min.js"> </script>
     <script type="text/javascript">
         window.onload = function () {
             Gifffer();
             Inhoudsopgave();
         }
     </script>
     <link rel="stylesheet" type="text/css" href="../../js+css/css/bjc-gifffer.css">
     <title> Hoofdstuk 6 Les 2: Data-representatie en Compressie, Pagina 4 </title>
 </head>

 <body>
     <div class="full">
         <h2> Zwevendekommagetallen </h2>
         <div class="learn">
             <p> <strong> Op deze pagina, </strong> ga je leren hoe computers niet-hele getallen opslaan.
             </p>
         </div>
         <p>
             De manier waarop computers getallen op slaan die niet heel zijn heet <strong>zwevendekommagetal</strong>.
         </p>
         <div class="endnote"> <a href="#hint-float" data-toggle="collapse"> Waar komt die rare naam vandaan? </a>
             <div id="hint-float" class="collapse">
                 Deze rare naam wordt gebruikt omdat er vroeger een <em>vastkommagetal-</em>notatie was voor niet-hele
                 getallen met een vast aantal getallen achter de komma. Bijvoorbeeld een vastekommagetalnotatie met 2
                 getallen achter de komma werd gebruikt om een hoevelheid geld in euro's en centen te laten zien. Omdat
                 geldbedragen altijd maar 2 getallen achter de komma hebben. Maar tegenwoordig gebruiken computers
                 altijd zwevendekommagetallen om niet-hele getallen te laten zien, zelfs voor geld.
             </div>
         </div>
         <div class="takeNote">
             Zwevendekommagetallen laten computers hele grote getallen opslaan, inclusief decimalen, maar het gebruikt
             nog steeds een specifiek aantal bits en dat zorgt ervoor dat er een limiet zit op de reeks waardes die een
             zwevendekommagetal aan kan namen, net als met hele getallen. Maar waardes die buiten de reeks vallen bij
             zwevendekommagetallen, kunnen resulteren in <em>afrond</em>fouten.
         </div>
         <div class="forYouToDo" id="first">
             <ol>
                 <li>
                     Probeer bijvoorbeeld <img src="../../afb/h6/l2/p4-o1.png" alt="Geen Afbeelding"> een keer met
                     bignums aan en een keer zonder.
                 </li>
             </ol>
         </div>
         <p>
             De decimale vertegenwoordiging van ⅓ is 0.33333... Het bevat oneindig veel cijfers dus het dichtstbij dat
             je kan komen met een zwevendekommagetal is niet <em>precies</em> ⅓. Op een bepaald moment houdt het op
             omdat je computer niet genoeg geheugen heeft.
         </p>
         <p>
             Afrondfouten kunnen zorgen voor onintuïtieve resultaten...
         </p>
         <div class="forYouToDo">
             <ol start="2">
                 <li> Probeer <img class="inline" src="../../afb/h6/l2/p4-o2.png" alt="Geen Afbeelding" /> en
                     dan <img class="inline" src="../../afb/h6/l2/p4-o3.png" alt="Geen Afbeelding" />. </li>
             </ol>
         </div>
         <p> Dit is geen bug in Snap<em>!</em>, Snap<em>!</em> rapporteert netjes het resultaat dat berekent wordt
             volgens de hardware voor een zwevendekommagetal.
         </p>
         <div class="endnote">
             <a href="#hint-roundoff" data-toggle="collapse"> Hoe kan een simpele berekening zulke foute resultaten
                 geven? </a>
             <div id="hint-roundoff" class="collapse">
                 Deze resultaten lijken verrassend omdat een breuk zoals 2/10, exact kan worden opgeschreven <em>in
                     decimalen</em>, als 0.2 namelijk (in tegenstelling tot ⅓). Maar met <em>binaire</em> getallen
                 kunnen alleen breuken waarbij de noemer (het onderste getal) 2 is, exact worden weergegeven. Dus 2/16
                 kan wel, maar 2/10 niet.
                 Het afgeronde getal waarmee in binair 0.2 wordt weergegeven is net ietsje groter dan 0.2, Dit geldt ook
                 voor het afgeronde getal van 0.4, samen zijn deze 2 afrondfouten zo groot dat de optelsom van 0.2 en
                 0.4 niet meer klopt.
             </div>
         </div>
         <p>
             Hoe goed de hardware ook is, bepaalde soorten berekeningen geven waarschijnlijk grove fouten met
             zwevendekommagetallen. Een simpel voorbeeld is twee getallen van elkaar aftrekken die heel dicht bij elkaar
             liggen. Het correcte antwoord ligt in dat geval in de buurt van nul en als de getallen dicht genoeg bij
             elkaar liggen zal door afrondfouten het resultaat van de berekening <em>onderstromen</em>. Dit betekent dat
             het gerapporteerde resultaat <em>lager</em> ligt dan het daadwerkelijke resultaat. Dus bij de aftreksom 2 -
             2.0001 wordt dan 0 gerapporteerd in plaats van 0.0001.
         </p>
         <div class="endnote"> <a href="#hint-killer" data-toggle="collapse">
                 Fouten door zwevendekommmagetallen kunnen heel duur zijn en zelfs zorgen voor slachtoffers.
             </a>
             <div id="hint-killer" class="collapse">
                 <p> Een beroemd voorbeeld is de Ariane-raket die gelanceerd werd op 4 Juni 1996. Tijdens de 37ste
                     seconde van de vlucht, probeerde het systeem een 64-bit zwevendekommagetal om te zetten in een
                     16-bitgetal, maar in plaats daarvan werd er een overstroomfout gerapporteerd, wat werd
                     geïnterpreteerd door het navigatiesysteem als vliegdata. Dit zorgde ervoor dat de raket van zijn
                     koers ging en zichzelf verwoestte.
                 </p>
                 <p> Het Patriot-raketafweersysteem dat gebruikt werd tijdens de Golfoorlog had ook last van een
                     afrondfout (Skeel 1992, U.S. GAO 1992). Het systeem gebruikte een tijdmeter die werkte met hele
                     getallen en optelde met intervallen van 0.1 secondes. Het probleem was dat de hele getallen
                     werden omgezet in decimale getallen door zich te vermenigvuldigen met de binaire benadering van
                     0.1: 0.00011001100110011001100 <sub> 2 </sub> = 209715/2097152.
                 </p>
                 <p> Dit betekende dat na 100 uur (3.6 &times; 10 <sup> 6 </sup> tellen), er een fout was van </p>
                 <p class="indent">
                     <span class="katex">
                         (\frac{1}{10}-\frac{209715}{2097152})(3600\times100\times10)=\frac{5625}{16384}
                         \approx 0.3433 \text{ seconds} </span>
                 </p>
                 <p> Dit verschil zorgde ervoor dat het systeem niet meer goed zijn doel kon vinden. Toen dus later een
                     Irakese raket werd afgevuurd die niet werd gestopt door het systeem, kwamen er 28 mensen om het
                     leven.
                 </p>
                 <p> <small>
                         Overgenomen van <em> Analoge en Digitale Conversie (Engels) </em> , door Wikibooks bijdragers,
                         <a href="https://en.wikibooks.org/wiki/Analog_and_Digital_Conversion/Fixed_Wordlength_Effects"
                             target="_blank">
                             https://en.wikibooks.org/wiki/Analog_and_Digital_Conversion/Fixed_Wordlength_Effects
                         </a> </small>
                 </p>
             </div>
         </div>
         <p> Computerberekeningen met <em>hele getallen</em> zijn simpel: of je krijgt een correct, heel
             getal of als het resultaat niet past in (niet-bignum) een heel getal dan krijg je een
             <em>overstroomfout</em> en wordt het resultaat, als het goed is, omgezet in een zwevendekommagetal (zoals
             bij 30!).
         </p>
         <p> Computerberekeningen met <em>zwevendekommagetallen</em> daarentegen zijn moeilijk om precies goed te
             krijgen. Voor 1985 had ieder computermodel een ander formaat zwevendekommagetal en allemaal gaven ze
             foute antwoorden op bepaalde vragen. Deze situatie werd opgelost door de <a
                 href="https://nl.wikipedia.org/wiki/IEEE_754" target="_blank"> IEEE 754 zwevendekommastandaard </a> die
             nu door iedere computerfabrikant gebruikt wordt.
         </p>
         <div class="endnote"> <a href="#hint-alternatives" data-toggle="collapse">
                 Er zijn alternatieven voor zwevende komma's. </a>
             <div id="hint-alternatives" class="collapse">
                 Als de kleine fouten die veroorzaakt worden door zwevendekommagetallen onacceptabel blijken te zijn in
                 bepaalde gevallen, dan kan een programma ervoor kiezen alternatie notaties te gebruiken:
                 <ul>
                     <li> <strong> Exacte Rationale getallen. </strong> Twee bignums, één voor de noemer en één voor de
                         teller, kunnen gebruikt worden om een breuk precies te noteren.
                     </li>
                     <li> <strong> Binair gecodeerde decimalen. </strong> Een decimaal getal kan genoteerd worden
                         met vier bits, de niet gebruikte bit-combinaties kunnen gebruikt worden voor voor een minteken
                         en een komma. Een reeks van deze decimale cijfers kan gebruikt
                         worden om een decimaal getal weer te geven. Je kan zo ook een breuk in decimalen weergeven dat
                         precies een breuk noteert met een eindig aantal
                         van deze binair-gecodeerde decimalen. Dus stel dat we de code 1110 voor . gebruiken, dan is
                         1.32 gelijk aan <code>0001 1110 0011 0010</code>.
                         Dit voorkomt het 0.2+0.4-probleem, maar werkt niet voor breuken die in decimaal een oneindige
                         reeks cijfers nodig hebben zoals ⅓.
                     </li>
                     <li> <strong> Decimale zwevendekommagetallen. </strong> Als de notatie met binair gecodeerde
                         decimalen van hierboven wordt uitgebreid met een bit-combinatie die zegt "keer tien tot de
                         macht" kunnen decimale getallen met de wetenschappelijke notatie genoteerd kunnen worden. Dus
                         stel dat de code voor "keer tien tot de macht" gelijk is aan <code>1111</code>, dan is 2.5e+4
                         gelijk aan: <code>0010 1110 0101 1111 0100</code>. (We hebben gezien in de vorige les dat e+
                         gelijk is aan "keer tien tot de macht")
                     </li>
                 </ul>
             </div>
         </div>

         <p> Zonder bignums wordt een resultaat dat te groot is voor een heel getal, omgezet in een zwevendekommagetal.
             <br />
             <img class="indent" src="../../afb/h6/l2/p4-o4.png" alt="Geen Afbeelding" />
         </p>
         <div class="forYouToDo">
             <ol start="3">
                 <li> Probeer 200! zonder bignums. <br />
                     <img src="../../afb/h6/l2/p4-o5.png" alt="Geen Afbeelding" /> </li>
             </ol>
         </div>

         <p> <strong> Wat gebeurt er? </strong> Ook al is 200! vrij groot het is niet "oneindig". Het foute resultaat
             wordt veroorzaakt door de limiet van de grootte van zwevendekommagetallen. Als het resultaat van de
             berekening groter is dan kan worden opgeslagen dan rapporteert de computer een speciale code
             die de taal interpreteert als Oneindig of ∞.
         </p>

         <div class="endnote">
             Voor zwevendekommagetallen zijn er speciale codes voor oneindig, -oneindig (kleiner dan elke andere
             waarde) en "Niet een Getal" (afgekort als NaN in het Engels) dat gebruikt wordt als resultaat voor een
             illegale berekening zoals 0/0. <br />
             <img class="indent" src="../../afb/h6/l2/p4-o6.png" alt="Geen Afbeelding" />
         </div>

         <div class="takeItFurther">
             <ol type="A">
                 <li> Stel je een <em>decimaal</em> zwevendekommagetal voor met één significant getal en een
                     exponent van 10 <sup> -2 </sup> tot 10 <sup> 2 </sup> .
                     Het kleinste positieve getal dat we kunnen weergeven met deze notatie is 0.01 (1×10 <sup> -2 </sup>
                     ) en het grootste getal is 900 (9×10 <sup> 2 </sup> ). Schets een getallenlijn van 0 tot 1000 en
                     markeer al de positieve waardes die we kunnen weergeven met deze notatie. Wat kan je zeggen over de
                     afstand tussen de waarde? Hoeveel breuken kunnen weergegeven worden? Hoeveel hele getallen onder de
                     1000 kunnen <em>niet</em> weergegeven worden? Wat zijn de voor- en nadelen van deze notatie? (Echte
                     zwevendekommagetallen hebben veel meer waardes die weergegeven kunnen worden, maar de afstand op de
                     getallenlijn is vergelijkbaar met die van deze notatie.)
                 </li>
             </ol>
         </div>

         <p> <strong> Hoe weet een programmeertaal of het een bitreeks moet interpreteren als een heel getal, een
                 zwevendekommagetal, een stuk tekst of iets anders? </strong>
             Programmeertalen doen dit op verschillende manieren, maar er is altijd een aantal <em>extra</em> bits die
             aangeven wat het <em>data-type</em> is van een bitreeks, die dus vertelt aan de computer hoe de bitreeks
             geïnterpreteerd moet worden.

         </p>

         <div class="takeNote"> Op het laagste niveau van abstractie wordt <em>alles</em> in een computer weergegeven
             als een binaire reeks. Bijvoorbeeld: <ul>
                 <li> Een Boolean waarde is een enkele bit, 0 voor <code> onwaar </code> en 1 voor <code> waar
                     </code>. </li>
                 <li> Een stuk tekst is een reeks codes voor Unicode-symbolen, waarvan iedere code wordt opgeslagen als
                     een heel getal. </li>
                 <li> Lijsten en blokken zijn ook voorbeelden van binaire reeksen. </li>
             </ul>
         </div>

         <div class="endnote">
             <a href="#hint-data-types" data-toggle="collapse"> Maar verschillende talen gebruiken data-types op andere
                 manieren. </a>
             <div id="hint-data-types" class="collapse">
                 <p> In goed ontworpen talen (zoals talen gebaseerd op Scheme) zit het data-type vast aan de waarde
                     zelf, dit zijn talen met <em>dynamische waardes</em>. In andere talen is het zo dat wanneer je een
                     variabele aanmaakt, je moet zeggen wat voor type
                     waarde de variabele zal bevatten. Dan zit het data-type dus vast aan de <em>variabele</em>, talen
                     met dit systeem zijn talen met <em>statische waardes</em>. Stel je wilt een variabele <var>x</var>
                     de waarde 5 geven, in een taal met dynamische waardes zou dat er zo uit kunnen zien: <br>
                     <code> x = 5; </code> <br>
                     In een taal met statische waardes ziet dat er zo uit: <br>
                     <code> Getal x;</code><em>x wordt aangemaakt als een Getal-variabele.</em> <br>
                     <code> x = 5;</code> <em>x krijgt de waarde 5.</em><br>


                     <!--Zodra iemand dit uit kan leggen (zie h6l2p2) uncomment het maar
                     In well-designed languages (those based on Scheme, for example), that data type code is attached to
                     the value itself. In other languages, when you make a variable, you have to say what type of value
                     it will contain, and the data type is attached to the <em> variable </em> , so you can't both get
                     exact answers when the values are integers and also be able to handle non-integer values of the
                     same variable. So instead of seeing: <br />
                     <img class="indent" src="/bjc-r/4-internet/varfoo.png" alt="Geen Afbeelding"> <br />
                     you see things like: <br />
                     <img class="indent" src="/bjc-r/4-internet/intfoo.png" alt="Geen Afbeelding"> <br />
                     In a language with <em> dynamic typing </em> (where you don't have to declare the types of
                     variables) it's just as easy to make a list whose items are of different data types as it is to
                     make one whose items are all the same type (all integers or all character strings, etc.)
                     -->
                 </p>
                 <p>Snap<em>!</em> heeft pluspunten die veel andere talen niet hebben en het is zeer waarschijnlijk dat
                     je bij je <em>volgende</em> informaticacursus een taal met statische waardes zal leren gebruiken.
                 </p>
             </div>
         </div>
         <div class="forYouToDo">
             <ol start="4">
                 <li>
                     <!-- Question 1 -->
                     <div class="assessment-data" type="multiplechoice" identifier="Which explains the 0?"
                         hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="false">
                         <div class="prompt"> Een bepaald programma gebruikt 4 bits om hele getallen weer te geven.
                             Wanneer dat programma 9 en 7 optelt is het resultaat 0. Vind de beste verklaring voor dit
                             resultaat. </div>
                         <div class="choice" identifier="c1">
                             <div class="text"> Er is iets fout gegaan met de data tijdens de som door een technische
                                 fout
                             </div>
                             <div class="feedback"> Dit is mogelijk, maar het is geen verklaring als de fout blijft
                                 voorkomen als de som herhaald wordt.
                             </div>
                         </div>
                         <div class="choice" identifier="c2">
                             <div class="text"> Dit resultaat werd veroorzaakt door een afrondfout. </div>
                             <div class="feedback"> Er vond geen afronding plaats. </div>
                         </div>
                         <div class="choice" identifier="c3">
                             <div class="text"> Dit resultaat werd veroorzaakt door een overstroomfout. </div>
                             <div class="feedback"> Correct. 9+7=16, 16 kan niet worden uitgedrukt met 4 bits.
                                 0=(0000) <sub>2</sub> is het laagste getal en 15=(1111) <sub>2</sub> het hoogste wat
                                 uitgedrukt kan worden met een 4-bitsysteem.
                                 16=(10000) <sub> 2 </sub> zorgt voor een overstroomfout. </div>
                         </div>
                         <div class="choice" identifier="c4">
                             <div class="text"> Een zwevendekommagetal werd gebruikt om een benadering te geven van het
                                 resultaat.
                             </div>
                             <div class="feedback"> 0 is niet een benadering van 16. </div>
                         </div>
                         <div class="responseDeclaration" identifier="ri1">
                             <div class="correctResponse" identifier="c3"> </div>
                         </div>
                     </div>
                 </li>
             </ol>
         </div>
     </div>
     <div class="full-bottom-bar" style="background-position: 20px 3px;">
         <div class="bottom-nav btn-group"> <a class="btn btn-default backbutton arrow" style="min-width: 90px;"
                 href="H6L2P3.html"> Terug </a> <a class="btn btn-default forwardbutton arrow" style="min-width:90px;"
                 href="H6L2P5.html"> Volgende </a> </div>
     </div>
 </body>

 </html>