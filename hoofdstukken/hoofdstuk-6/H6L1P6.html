<!DOCTYPE html>
<html lang="nl">

<head>
    <link rel="icon" href="../../BJOC-NL-logo.png" type="image/png">
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="../../js+css/llab/loader.js"></script>
    <script type="text/javascript" src="../../js+css/gifffer.min.js"></script>
    <script type="text/javascript">
        window.onload = function () {
            Gifffer();
            Inhoudsopgave();
        }
    </script>
    <link rel="stylesheet" type="text/css" href="../../js+css/css/bjc-gifffer.css">
    <title>Hoofdstuk 6 Les 1: De Hiërarchie van Computer-abstractie, Pagina 6</title>
</head>

<body>
    <div class="full">
        <h2>Het digitale domein: architectuur</h2>

        <div class="learn"><strong>Op deze pagina</strong>, gaan we in plaats van naar software, kijken naar hardware.
            Het eerste onderwerp is <em>architectuur,</em>, dit kan je zien als de manier waarop de software de hardware
            ziet.</div>

        <p> De software in een computer is nutteloos zonder de <em>hardware:</em> de daadwerkelijke circuits in de
            computer. Net zoals er lagen van abstractie zijn voor software, denken hardware-designers ook in lagen van
            abstractie.
        </p>
        <img class="imageRight noshadow" src="../../afb/h6/l1/p6-o4.png" alt="Geen Afbeelding" />
        <p> Iedereen heeft het over computers die alle gegevens vertegenwoordigen met slechts twee waarden, 0 en 1. Maar
            dat is niet echt hoe elektronische circuits werken. Computerontwerpers kunnen doen <em> alsof </em>
            circuits uit (0) of aan (1) staan vanwege <strong> digitale abstractie </strong>, de belangrijkste
            abstractie in hardware. Boven dat abstractieniveau zijn er vier gedetailleerdere niveaus, deze horen in het
            <strong> digitale domein </strong> genoemd. Onder de digitale abstractie werken ontwerpers in het
            <strong> analoge domein </strong>, waarin een draad in een circuit elke mogelijke spanningswaarde kan
            hebben, niet
            slechts twee waarden.
        </p>
        <p> Op de volgende vier pagina's, zullen we vier lagen van het digitale domein verkennen.
        </p>


        <div class="endnote">
            <h3>De Stored program-computer (Computer met opgeslagen programma)</h3>
            <p> Zoals je zal zien in Les 3 zijn er al duizenden jaren machines die berekeningen uitvoeren. Maar de
                moderne, <em>programmeerbare</em> computer komt voort uit het werk van Charles Babbage in de vroege
                jaren van 1800.
            </p>
            <p> Babbage was vooral een wiskundige maar hij heeft veel bijgedragen aan onder andere astronomie en
                economie. Babbage leefde ongeveer 150 jaar geleden van 1791-1871. Dat elektriciteit als een bron van
                energie kon worden gebruikt was nog onbekend. De stoommachine werd populair rond de tijd dat hij werd
                geboren. De meeste precieze machines uit zijn tijd waren uurwerken.
            </p>

            <h4><strong>De Difference Engine</strong></h4>
            <p>Babbage's eerste computer was de Difference Engine (Verschilmotor).Hij gebruikten tandwielen om een
                ingewikkelde machine te ontwerpen die tabellen met getallen kon berekenen en printen (bijvoorbeld
                tabellen van logaritmische functies). Maar deze tandwielen moesten heel precies zijn en ieder tandwiel
                moest met de hand gemaakt worden. Het project werd zo duur dat de overheid de financiering stop moest
                zetten en Babbage maakte het project nooit af.
            </p>
            <table class="indent">
                <tr>
                    <td>
                        <img src="../../afb/h6/l1/p6-o1.jpg" height="200px" alt="Geen Afbeelding" />
                        <br />
                        <small>De Difference Engine in het London Science Museum</small>
                        <br />
                        <small><small>
                                Afbeelding van Wikimedia-gebruiker geni. Copyright 2008. Licentie: GFDL, CC BY-SA.
                            </small></small>
                    </td>
                    <td>
                        <img src="../../afb/h6/l1/p6-o2.jpg" height="200px" alt="Geen Afbeelding" />
                        <br />
                        <small>Een close-up die de tandwielen duidelijker laat zien</small>
                        <br />
                        <small><small>
                                Afbeelding van Carsten Ullrich. Copyright 2005. Licentie: CC-BY-SA-2.5.
                            </small></small>
                    </td>
                </tr>
            </table>

            <p>
                <a href="#hint-difference" data-toggle="collapse">
                    Leer meer over de geschiedenis van de Difference Engine.
                </a>
                <div id="hint-difference" class="collapse">

                    <p> In de tijd van Babbage werden dergelijke numerieke tabellen met de hand berekend door menselijke
                        wiskundigen, en ze werden met de hand opgeschreven om te worden afgedrukt. Zowel de berekening
                        als het
                        kopiëren naar print waren foutgevoelig, en nauwkeurige tabellen waren nodig voor doeleinden
                        variërend van engineering tot navigatie.
                    </p>
                    <p> Babbage bouwde eerst een kleine Difference Engine in 1822. Deze eerste poging bewees dat een
                        Difference Engine mogelijk was, maar het had niet de precisie (aantal cijfers in elk getal) om
                        praktisch te zijn. In 1823 financierde de Britse overheid Babbage om een grotere versie te
                        bouwen. Helaas konden metaalsmeden in zijn tijd niet erg precieze tandwielen in grote
                        hoeveelheden produceren; elk moest handgemaakt zijn. Dus had hij hij tien keer zijn
                        goedgekeurde budget besteed tegen de tijd dat de overheid het project in 1842 stopzette.
                    </p>
                    <p> In 1991 voltooide het London Science Museum een Difference Engine volgens het oorspronkelijke
                        ontwerp van Babbage met behulp van tandwielen gemaakt door moderne processen, maar op het niveau
                        van precisie dat beschikbaar was voor Babbage. Dit bewees dat Babbage in principe een werkende
                        machine had kunnen voltooien met voldoende tijd en geld.
                    </p>
                </div>
            </p>

            <h4><strong>De Analytical Engine</strong></h4>
            <p> De Difference Engine kan worden gebruikt om veel verschillende functies te berekenen door de
                startpositie van verschillende versnellingen handmatig in te stellen. Maar het had
                <strong> slechts één algoritme </strong>: het algoritme ingebouwd in het hardware-ontwerp. In 1833 begon
                Babbage te werken aan de Analytical Engine, die gebaseerd was op het algemene idee van de Difference
                Engine maar die wel <strong> instructies uit kon voeren </strong> in een primitieve programmeertaal die
                met ponskaarten werkte. <br />
                <div class="sidenote">
                    <small>Ponskaarten gebruikt om de Analytical Engine te programmeren</small><br />
                    <small><small>Karoly Lorentey. Copyright 2004. Licentie: CC-BY.</small></small>
                </div>
                <img class="indent" src="../../afb/h6/l1/p6-o3.jpg" height="300px" alt="Geen Afbeelding" />
            </p>

            <p> Tegenwoordig zijn we omringd door programmeerbare computers en het concept van software is nu
                vanzelfsprekend. Dit was niet altijd zo, vóór Babbage werden alle algoritmen rechtstreeks in
                hardware geïmplementeerd.
            </p>
            <p> Dus, 150 jaar geleden, maakte Babbage plannen voor wat in wezen een moderne computer is, hoewel hij geen
                elektronica beschikbaar had. Zijn onderliggende idee voor hardware was volledig mechanisch, maar het
                bleek niet mogelijk te zijn om het met de toenmalige technologie te bouwen. We hebben geen
                <em> bruikbare </em> computers gekregen totdat er een onderliggende technologie was die klein,
                goedkoop en snel genoeg was om de software-abstractie te ondersteunen. Je leert binnenkort over deze
                technologie, transistors.
            </p>
        </div>

        <div class="takeNote">
            De abstractie van <em>software</em> (een programma dat opgeslagen is in het geheugen van
            de computer) is wat een computer bruikbaar maakt voor meerdere doeleinden.
        </div>

        <div class="endnote">
            <p>
                <a href="#hint-analytical" data-toggle="collapse"> Leer meer over de Analytical Engine.</a>
                <div id="hint-analytical" class="collapse">
                    <p> De Analytical Engine, had net als moderne computers, een rekenkundige processor (genaamd de
                        "molen") en een apart geheugen (de "winkel") die 1000 getallen kon bijhouden, ieder tot en met
                        40 cijfers.
                        De molen voerde rekenkundige handelingen uit in decimalen (met cijfers 0-9 verdeeld
                        over ieder tandwiel); het gebruik van "enen en nullen" kwam pas later.
                    </p>
                    <p> De programmeertaal die gebruikt werd in de Analytical Engine had ook voorwaardes en lussen,
                        alles dat nodig is om een algoritme te maken. (Het kon lussen maken omdat het voorwaarts
                        en achterwaarts door de ponskaarten kon gaan.)
                    </p>
                    <p> Helaas kon Babbage maar een klein deel van de Analytical Engine bouwen, die nog meer metaalwerk
                        nodig had dan de Difference Engine. Zijn aantekeningen over het ontwerp waren niet volledig en
                        dus heeft niemand ooit een werkend model gebouwd, alhoewel er simulaties zijn op het internet
                        (zie het Ga Een Stapje Verder-probleem hieronder). Jammer genoeg was Babbage werk niet bekend in
                        de vroege dagen van elektronische computers en veel mensen hebben zijn ideeën heruitgevonden.
                    </p>
                </div>
            </p>
            <p>
                <a href="#hint-ada" data-toggle="collapse"> Leer over Ada, Gravin Lovelace's uitvinding van symbolisch
                    programmeren.
                </a>
                <div id="hint-ada" class="collapse">
                    <p> Alhoewel zijn ontwerp zeer veelzijdig was, was Babbage vooral geïnteresseerd
                        in het afdrukken van getallentabellen. Het was zijn medewerker Augusta Ada King-Noel, gravin van
                        Lovelace, die voor het eerst inzag dat de nummers in de computer van Babbage niet alleen als
                        hoeveelheden konden worden gebruikt, maar ook als weergave van muzieknoten, letters,
                        enzovoort. </p>
                    <img class="indent" height="300px" src="../../afb/h6/l1/p6-o5.jpg" alt="Geen Afbeelding" />
                    <div class="sidenote">
                        <small>Afbeelding van Alfred Edward Chalon, Science &amp; Society Picture Library, Publiek
                            Domein, via
                            Wikimedia.</small>
                    </div>

                    <p> Veel van wat we vandaag weten over het ontwerp van Babbage komt uit de uitgebreide aantekeningen
                        van Ada Lovelace over zijn ontwerp. Haar aantekeningen omvatten het eerste <em> gepubliceerde
                        </em> programma voor de Analytical Engine, en daarom wordt ze algemeen beschouwd als "de eerste
                        programmeur", hoewel het bijna zeker is dat Babbage zelf verschillende voorbeeldprogramma's
                        heeft geschreven tijdens het ontwerpen van de machine.
                    </p>
                    <p> Of ze nu echt de eerste programmeur was of niet, historici zijn het erover eens dat ze iets
                        belangrijkers heeft gedaan: ze heeft het idee van <em> symbolische </em> berekening
                        (inclusief tekst, afbeeldingen, muziek, etc.) naar numerieke berekening uitgevonden. Dit
                        inzicht maakte de weg vrij voor alle manieren waarop computers tegenwoordig worden gebruikt,
                        van Netflix tot stem-interactieve programma's zoals Siri en Alexa. </p>
                </div>
            </p>
        </div>

        <h3>Wat is een Architectuur?</h3>
        <p>De Analytical Engine (boven beschreven) was de eerste programmeerbare computerarchitectuur.
            De processor in de computer die je nu gebruikt begrijpt maar één taal: zijn eigen <em>machinetaal</em>, geen
            Java, C of Snap<em>!</em>, of iets anders. Programma's die geschreven zijn in die andere talen moeten eerst
            vertaald worden naar machinetaal.
        </p>
        <p> Het belangrijkste van de architectuur is de machinetaal. De set instructies van zeer laag niveau die de
            hardware begrijpt. Deze taal is een soort contract tussen de hardware en de software: De hardware belooft de
            instructies te begrijpen en de software compileert programma's van mens-vriendelijke taal naar deze
            instructies.
        </p>

        <div class="vocabFullWidth">
            <p><strong>Machinetaal</strong> is de programmeertaal op het laagste niveau; het wordt direct begrepen door
                de hardware.
            </p>
            <p><strong>Architectuur</strong> is een abstractie, een specificate van de machinetaal. Het zegt ook hoe de
                processor verbonden is met het geheugen. Het specificeert niets van de circuits; dezelfde architectuur
                kan op meerdere manieren worden gebouwd qua circuits.

        </div>
        <p> Een belangrijk onderdeel van een architectuur is het aantal draden dat de processor met het geheugen
            verbindt. Dit wordt de <em> breedte </em> van de architectuur genoemd, gemeten in <em> bits </em>
            (aantal draden). Een computer met een hogere breedte kan meer gegevens in één instructie verwerken. </p>

        <div class="endnote">
            <a href="#hint-machine-language" data-toggle="collapse">Hoe ziet machinetaal eruit?</a>
            <div id="hint-machine-language" class="collapse">
                <p>
                    Bekijk de Snap<em>!</em>-instructie
                    <img class="inline nopad" src="../../afb/h6/l1/p6-b1.png" alt="Geen Afbeelding" />.
                    In een taal op laag niveau zoals C of Java zou het zelfde idee geschreven als: <br />
                    <pre>c = a+b;</pre>
                    Dat simpele commando zou vertaald kunnen worden in <em>zes</em> machinetaalinstructies (een beetje
                    versimpeld): <br />
                    <pre>
movq    _c, %rcx
movq    _b, %rdx
movq    _a, %rsi
movl    (%rsi), %edi
addl    (%rdx), %edi
movl    %edi, (%rcx)</pre>
                    Deze notatie, <em>assembly-taal</em> genaamd, is een regel voor regel-equivalent aan de
                    daadwerkelijke numerieke instructiecode, maar het is iets meer leesbaar.
                </p>
                <a href="#hint-assembly" data-toggle="collapse">Wat betekent de code?</a>
                <div id="hint-assembly" class="collapse">
                    <p>De eerste drie instructies laden de <em>adressen</em> van de drie variabelen in de registers in
                        de processor. De namen met een percentage-teken zoals <code>%rcx</code> verwijzen naar
                        specifieke registers.
                        <code>Movq</code> is de naam van een machinetaalinstructie.
                        (Het is een
                        afkorting voor "move quote", wat betekent dat we een constante waarde in een register plaatsen.
                        Merk op dat <var>a</var> een variabele is, maar <em>het adres van</em> <var>a</var> is een
                        constante waarde, omdat de variabele niet wordt verplaatst in het geheugen.)
                    </p>
                    <p> De volgende instructie, <code>movl</code> ("move long"), zegt dat een woord van de ene plek naar
                        de andere moet worden verplaatst. Als een registernaam tussen haakjes staat zoals
                        <code>(%rsi</code> dan betekent dat dat we locatie in het geheugen gebruiken van wie het adres
                        in dat register staat.
                        Omdat de derde <code>movq</code> het adres van <var>a</var> in register
                        <code>%rsi</code> heeft geplaatst zegt de eerste <code>movl</code> dat de variabele <var>a</var>
                        van het geheugen in de processorregister moet worden geplaatst.
                        De instructie <code>addl</code> zegt dat <var>b</var> moet worden toegevoegd aan hetzelfde
                        register. Aan het einde wordt de waarde in register <code>%edi</code> in de geheugen locatie
                        geplaatst van variabele <var>c</var>.
                    </p>
                </div>
                <p> Je wil niet moeten programmeren in deze taal! En dat <em> hoeft ook niet</em> ; moderne
                    architecturen zijn ontworpen voor compilers, niet voor machinetaalprogrammeurs.
                </p>
            </div>
        </div>
        <div class="endnote">
            Leer over:
            <ul>
                <li>
                    <a href="#hint-architecture" data-toggle="collapse">PC/Mac-architectuur</a>
                    <div id="hint-architecture" class="collapse">

                        <p> De meeste computerprocessors (het onderdeel dat instructies uitvoert) op desktop- of
                            laptopcomputers gebruiken een architectuur genaamd "x86" die is ontworpen door Intel, een
                            chipfabrikant. De eerste processor die die architectuur gebruikte, heette de 8086,
                            uitgebracht in 1978. (De reden voor de naam x86 is dat de eerste paar verbeterde versies
                            80286, 80486, enz. Werden genoemd.) De originele 8086 was een 16-bitarchitectuur; sindsdien
                            zijn 32-bit (sinds 1985) en 64-bit (sinds 2003) versies ontwikkeld. Zelfs met alle
                            verfijningen van de architectuur zijn de nieuwe x86-processors bijna altijd
                            <em> backwards compatible </em> wat betekent dat de versies van vandaag nog steeds
                            programma's uitvoeren die zijn geschreven voor de originele 8086.
                        </p>
                        <p> Waarom is de x86-architectuur de wereld gaan regeren? Het korte antwoord is dat IBM het in
                            hun oorspronkelijke pc gebruikte en dat alle latere pc-fabrikanten hun voorbeeld volgden
                            zodat software die op een IBM computer werkt, ook op hun computer werkt. Maar waarom koos
                            IBM voor de x86?
                            Er waren aantoonbaar beter concurrerende architecturen beschikbaar, zoals
                            de Motorola 68000 en de eigen 801 van IBM. De pc-ontwerpers hadden ruzie over wat ze moesten
                            gebruiken, maar uiteindelijk maakte het verschil de lange geschiedenis van samenwerking van
                            IBM en Intel.
                        </p>
                        <p> De Apple Macintosh gebruikte oorspronkelijk de Motorola 68000-architectuur en in 1994
                            ontwierp Apple zijn eigen PowerPC-architectuur in een gezamenlijk project met IBM en
                            Motorola, maar in 2006 schakelden ze ook over op de x86, omdat Intel nieuwere, snellere
                            versies van de x86 blijft produceren, vaker dan andere bedrijven kunnen bijhouden.
                        </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-phone" data-toggle="collapse">Smartphone-architectuur</a>
                    <div id="hint-architecture-phone" class="collapse">
                        <p> Alles van smartphone-architectuur wordt bepaald door de kleine ruimte in de behuizing. De
                            hoogte en breedte van de telefoon worden beperkt door de grootte van de zakken in de kleding
                            van mensen.
                            <em> (Houd je telefoon niet in je achterbroekzak. Dat is echt slecht, zowel voor
                                de telefoon als voor je rug.) </em>
                            De dikte van een telefoon kan veel groter zijn dan nu vaak het
                            geval is , maar om de een of andere reden concurreren telefoonfabrikanten op de dunheid van
                            hun telefoons, waardoor ontwerpers nog minder ruimte hebben.
                        </p>
                        <p> Als gevolg hiervan zijn veel componenten die gescheiden zouden zijn van de processorchip in
                            een computer, onderdeel van de processorchip in een telefoon. Deze componenten
                            kunnen bestaan uit een mobiele modem, een WiFi-modem, een grafische processor
                            (een processor die is gespecialiseerd in parallel rekenen met lijsten van
                            nummers), geheugen, een GPS-ontvanger om de fysieke locatie van je telefoon te vinden,
                            circuits om de stroom en batterij te beheren en meer. Tegenwoordig bevat de chip
                            waarschijnlijk twee, vier of zelfs acht kopieën van de werkelijke CPU om multicore-systemen
                            te maken. Deze verzameling componenten wordt een <em> systeem op een chip, </em> of SoC
                            genoemd. </p>
                        <p> Intel heeft een x86-gebaseerde (dat wil zeggen dezelfde architectuur die op pc's wordt
                            gebruikt) low-power SoC gemaakt genaamd de Atom, die werd gebruikt in een paar
                            Motorola-telefoons en andere telefoons die zijn gemaakt door bedrijven waar je nog nooit van
                            hebt gehoord. Het is gemaakt om Android-, Linux- en Windows-telefoons te ondersteunen. </p>
                        <p> Maar de overgrote meerderheid van de telefoons gebruikt de ARM-architectuur, die (in
                            tegenstelling tot de x86) vanaf het begin is ontworpen als een energiezuinige architectuur.
                            Het acroniem staat voor Advanced RISC Machine. Het is beschikbaar in 32-bit- en
                            64-bitconfiguraties.
                        </p>

                        <div class="endnote">
                            <a href="#hint-risc" data-toggle="collapse">What is een RISC?</a>
                            <div id="hint-risc" class="collapse">
                                <p> De naam staat voor Reduced Instruction Set Computer
                                    (Verkleinde-Instructiesetcomputer), in tegenstelling tot de CISC-architectuur
                                    (Complex Instruction Set Computer dus de Complexe-Instructiesetcomputer), inclusief
                                    de x86. De <em> instructieset </em> van een architectuur is, zoals je uit de naam
                                    kunt raden, de set instructies die de processor begrijpt. Een RISC heeft minder
                                    instructies dan een CISC, maar is ook op andere manieren eenvoudiger. Een CISC heeft
                                    bijvoorbeeld doorgaans meer <em> adresseermodi </em> in de instructies. In de
                                    x86-architectuur kan de instructie <code> add </code> twee processorregisters
                                    toevoegen, of een register en een waarde uit het geheugen van de computer, of een
                                    constante waarde die in de instructie zelf is ingebouwd. De instructie <code> add
                                    </code> van een RISC-architectuur weet gewoon hoe hij twee registers moet toevoegen
                                    (misschien moet het resultaat in een derde register geplaatst worden), en er zijn
                                    afzonderlijke <code> load </code> en <code> store </code> instructies die waarden
                                    uit het geheugen kopiëren in een register of andersom. Ook hebben in een
                                    RISC-architectuur alle instructies dezelfde lengte (bijvoorbeeld 32 bits), terwijl
                                    in een CISC-architectuur de instructielengtes kunnen variëren. Deze verschillen zijn
                                    belangrijk omdat een RISC de volgende instructie kan laden voordat deze klaar is met
                                    de vorige instructie en een RISC nooit meer dan één geheugengegevensreferentie per
                                    instructie heeft.
                                </p>
                                <p> Dus waarom gebruiken ze geen RISC architectuur in pc's? Ooit gebruikte Apple een
                                    RISC-processor genaamd de PowerPC in zijn Macintosh-computers, maar de overgrote
                                    meerderheid van de verkochte computers zijn pc's, geen Mac's, en als gevolg daarvan
                                    besteedt Intel enorme bedragen aan het bouwen van snellere en snellere circuits die
                                    de x86-architectuur implementeren. De moraal gaat over de interactie tussen
                                    verschillende abstractieniveaus: een betere architectuur kan worden overwonnen door
                                    een beter circuitontwerp of betere technologie om componenten in een geïntegreerd
                                    circuit te proppen.
                                </p>
                            </div>
                        </div>
                        <p> Het bedrijf dat de ARM heeft ontworpen, genaamd ARM Holdings, bouwt eigenlijk geen
                            processors. Ze verlenen een licentie voor het architectuurontwerp of circuitontwerp aan
                            andere bedrijven die ARM-processors integreren in SoC's. Grote bedrijven
                            die op ARM gebaseerde processorchips bouwen, zijn Apple, Broadcom, Qualcomm en Samsung.
                            Fabrikanten van smartphones kopen chips van een van deze bedrijven.
                        </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-iot" data-toggle="collapse">Ingebouwde Architectuur en het "Internet of
                        Things"</a>
                    <div id="hint-architecture-iot" class="collapse">
                        <p> Je kunt thermostaten kopen met computers erin, koelkasten met computers erin, pluizig
                            dierenspeelgoed met computers erin - meer en meer dingen, naarmate de tijd verstrijkt.
                            Moderne auto's bevatten <em> meerdere </em> computers, grotendeels om veiligheidsredenen; je
                            zou niet willen dat de remmen falen omdat de dvd-speler een probleem heeft. Het doel, zoals
                            beschreven door onderzoekers in de informatica, is "smart dust" (slim stof), wat betekent
                            dat veel computers onopgemerkt door een gebouw kunnen zweven. Wat heb je aan een
                            onopgemerkte computer? Dit is een klassieke technologie voor dubbel gebruik. Het nuttige
                            gebruik waar iedereen het over heeft, is noodhulp bij rampen; het zou een grote hulp zijn
                            voor de brandweer om van buitenaf te weten in welke ruimtes van een gebouw mensen aanwezig
                            zijn. Maar een ander gebruik voor deze technologie zou spioneren zijn.
                        </p>

                        <p class="indent">
                            <img src="../../afb/h6/l1/p6-o6.jpg" alt="Geen Afbeelding"><br />
                            <small><small>NXP Freescale SCM-i.MX6D chip</small></small>
                        </p>
                        <p> Voor ingebouwde computers zijn de belangrijkste ontwerpcriteria kleine afmetingen en een
                            laag stroomverbruik. De chip in de bovenstaande afbeelding is gebaseerd op de
                            ARM-architectuur, zoals de meeste mobiele telefoons. Dat is eigenlijk een <em> grote </em>
                            chip voor ingebouwde systemen; de Kinetis KL02 MCU (microcontroller-eenheid) past in een
                            vierkant van 2 millimeter. Dat is nog steeds te groot om als stof in de lucht te zweven,
                            maar stel je het voor op de muur in een kleverige container.
                        </p>
                        <p> Op een dag zal het spioneren nog effectiever zijn (samen met, hopelijk, behandeling voor
                            hersenziekten): <a
                                href="https://www.engadget.com/2017/05/17/arm-targets-your-brain-with-new-implantable-chips/"
                                target="_blank">ARM richt zich op je brein met nieuwe implanteerbare chips (Engels)</a>
                            (Engadget, 5/17/2017).
                        </p>
                        <p> Intel maakte in 2015 een x86-compatibele chip ter grootte van een knop, maar kondigde in
                            2017 aan dat dit zo zou zijn stopgezet, waardoor alleen ARM- en PowerPC-gebaseerde
                            processors op de markt blijven concurreren.
                        </p>
                    </div>
                </li>
                <li>
                    <a href="#hint-architecture-hobby" data-toggle="collapse">Hobby-computerarchitectuur</a>
                    <div id="hint-architecture-hobby" class="collapse">

                        <p> In zekere zin kan <em> elke </em> architectuur een hobby-architectuur zijn. Zelfs in
                            de tijd van computers van een miljoen dollar waren er softwarehobbyisten die manieren vonden
                            om naar computerlokalen op de universiteit te gaan, vaak door zichzelf daar nuttig te maken.
                            Tegenwoordig zijn er veel meer krachtige computers die goedkoop genoeg zijn dat hobbyisten
                            ze uit elkaar willen halen. Maar er zijn enkele computerarchitecturen <em> specifiek </em>
                            bedoeld voor hobbyisten.
                        </p>
                        <img class="imageRight" src="../../afb/h6/l1/p6-o7.jpg" alt="Geen Afbeelding" />
                        <p> Veruit de meest populaire computer specifiek voor hobbyisten is de Arduino. Het is een
                            printplaat, niet alleen een processor. Rond de randen van het bord zitten connectoren. Aan
                            de korte rand links in de afbeelding bevindt zich de stroomingang, die kan worden
                            aangesloten op een voeding die is aangesloten op een stopcontact of op een batterij voor een
                            mobiel
                            apparaat zoals een robot, en een USB-aansluiting die voornamelijk wordt gebruikt om
                            programma's te downloaden van een desktop of laptop computer. Aan de lange randen bevinden
                            zich connectoren voor afzonderlijke draden die zijn aangesloten op externe sensoren (voor
                            licht, warmte, bij een muur zijn, een ander object aanraken, enz.) Of actuatoren
                            (stappenmotoren, lichten, zoemers, enz.).
                        </p>
                        <p> Een belangrijk aspect van het Arduino-ontwerp is dat het <em> vrij </em> is ("vrij als
                            in vrijheid"). Iedereen kan de Arduino maken en zelfs verkopen. Dit is goed
                            omdat het de prijs laag houdt (het standaard Arduino Uno-bord kost $ 22) en stimuleert
                            innovatie, maar het betekent ook dat er incompatibele Arduino-achtige boards kunnen zijn.
                            (De naam "Arduino" is een handelsmerk dat alleen kan worden gebruikt met een licentie van
                            Arduino AG.)
                        </p>
                        <p> De processor in de meeste Arduino-modellen is een 8-bit RISC-systeem met geheugen in de
                            chip, genaamd AVR, van een bedrijf genaamd Atmel. Het werd ontworpen door twee
                            (toenmalige) studenten in Noorwegen, Alf-Egil Bogen en Vegard Wollan genaamd. Hoewel
                            officieel "AVR" nergens voor staat, wordt algemeen aangenomen dat het afkomstig is van " Alf
                            en Vegard hun RISC". Er zijn verschillende versies van de AVR-processor, met verschillende
                            snelheden, geheugencapaciteiten en natuurlijk prijzen; er zijn verschillende
                            Arduino-modellen die de verschillende processors gebruiken.
                        </p>
                        <p> In tegenstelling tot de meeste ("von Neumann-architectuur") computers, scheidt de AVR
                            ("Harvard-architectuur") programmageheugen van gegevensgeheugen. (Het heeft eigenlijk <em>
                                drie </em> soorten geheugen, een voor het actieve programma, een voor gegevens op korte
                            termijn en een voor gegevens op lange termijn.) De Analytical Engine van Babbage is ook
                            ontworpen met een programmageheugen dat los staat van zijn data geheugen.
                        </p>

                        <div class="endnote">
                            <a href="#hint-Harvard" data-toggle="collapse">
                                Waarom zou je meer dan één soort geheugen willen?
                            </a>
                            <div id="hint-Harvard" class="collapse">
                                <p> Er zijn eigenlijk twee verschillende ontwerpproblemen in deze architectuur. Een
                                    daarvan is helemaal in het analoge domein en heeft te maken met het soort fysieke
                                    circuits
                                    dat wordt gebruikt. Er zijn <em> veel </em> geheugentechnologieën, variërend in
                                    kosten, snelheid en <em> vluchtigheid: </em> vluchtig geheugen verliest de
                                    informatie die erin is opgeslagen wanneer het apparaat wordt uitgeschakeld, terwijl
                                    niet-vluchtig geheugen de informatie behoudt. Dit is hoe geheugen wordt gebruikt in
                                    de AVR-chips: <ul>
                                        <li> <strong> EEPROM </strong> (512 Bytes – 4kBytes) is niet-vluchtig en wordt
                                            gebruikt voor gegevens op zeer lange termijn, zoals een bestand op een
                                            computer schijf, behalve dat er slechts een kleine hoeveelheid beschikbaar
                                            is. Programma's op de Arduino moeten expliciet vragen om dit geheugen te
                                            gebruiken, met een EEPROM-bibliotheek. <ul>
                                                <li> De naam staat voor Electrically Erasable Programmable Read-Only
                                                    Memory (Elektrisch-Verwijderbaar Programmeerbaar
                                                    Alleen-te-Lezen-Geheugen), wat klinkt als een contradictio in
                                                    terminis. In de
                                                    begindagen van op transistor gebaseerde computers waren er twee
                                                    soorten geheugen, vluchtig (Random Access Memory of RAM) en
                                                    niet-vluchtig (Read-Only Memory of ROM). De waarden die in een
                                                    vroege ROM waren opgeslagen, moesten door de fabrikant van de
                                                    geheugenchip worden ingebouwd, dus het was duur om een nieuwe te
                                                    laten maken. Toen kwam Programmable Read-Only Memory (PROM), dat
                                                    alleen kon worden gelezen als het eenmaal geïnstalleerd was op een
                                                    computer, maar het kon
                                                    worden geprogrammeerd, eenmalig, met behulp van een machine die
                                                    slechts enigszins duur was. Toen kwam EPROM, Erasable PROM, dat in
                                                    zijn geheel kon worden gewist door er een helder ultraviolet licht
                                                    op te laten schijnen en vervolgens opnieuw te programmeren als een
                                                    PROM. Eindelijk was er Electrically Erasable PROM, dat tijdens het
                                                    installeren op een computer kon worden gewist, dus in wezen gelijk
                                                    aan RAM, behalve dat het wissen veel langzamer is dan een iets in
                                                    RAM herschrijven, dus je gebruikt het alleen voor waarden die niet
                                                    van vaak gewijzigd worden. </li>
                                            </ul>
                                        </li>
                                        <li> <strong> SRAM </strong> (1k – 4kBytes): dit geheugen kan zijn waarde
                                            verliezen wanneer de machine wordt uitgeschakeld; met andere woorden, het is
                                            vluchtig. Het wordt gebruikt voor tijdelijke gegevens, zoals de
                                            scriptvariabelen in een Snap<em>!</em>-script. <ul>
                                                <li> De naam staat voor Static Random Access Memory (Statische
                                                    Willekeurigetoeganggeheugen). Het "Random Access"
                                                    -gedeelte onderscheidt het van de magnetische tape-opslag die op
                                                    zeer oude computers wordt gebruikt, waarbij het lang duurde om van
                                                    het ene uiteinde van de tape naar het andere te gaan, dus het was
                                                    alleen praktisch om achtereenvolgens gegevens te schrijven of lezen.
                                                    Tegenwoordig is alle computergeheugen willekeurige toegang, en de
                                                    naam "RAM" betekent echt "beschrijfbaar", in tegenstelling tot
                                                    alleen-lezen. Het "statische" deel van de naam betekent dat, hoewel
                                                    het geheugen stroom nodig heeft om zijn waarde te behouden, het <em>
                                                        niet </em> periodiek moet worden vernieuwd, zoals het gewone
                                                    ("dynamische") computerhoofdgeheugen dat wel doet. ("Vernieuwen"
                                                    betekent dat de computer om de zoveel tijd de waarde van elk stuk
                                                    in het geheugen moet lezen en dezelfde waarde moet herschrijven,
                                                    anders verdwijnt deze. Dit is een goed voorbeeld van
                                                    computercircuits waarvan het de taak is de <em> digitale abstractie,
                                                    </em> te behouden waarin een waarde nul of één is en er niet zoiets
                                                    bestaat als "vervagende" of "tussenliggende waarden".) Statische RAM
                                                    is sneller maar duurder dan dynamische RAM; daarom wordt DRAM
                                                    gebruikt voor de zeer grote (meerdere gigabytes) geheugens van
                                                    desktop- of laptopcomputers. </li>
                                            </ul>
                                        </li>
                                        <li> <strong> Flash </strong> geheugen (16k - 256kBytes): dit is het
                                            hoofdgeheugen dat wordt gebruikt voor programma's en gegevens.
                                            Flash-geheugen ken je waarschijnlijk, omdat het wordt gebruikt voor
                                            USB-sticks die fungeren als draagbare externe bestandsopslag. Het is
                                            technisch gezien een soort EEPROM, maar met een andere fysieke implementatie
                                            die
                                            het veel goedkoper maakt (dus er kan meer van zijn in de Arduino), maar
                                            ingewikkelder om te gebruiken, waarvoor speciale besturingsschakelingen
                                            nodig zijn om de digitale abstractie te behouden.
                                            <ul>
                                                <li> "Meer gecompliceerd" betekent bijvoorbeeld dat het wijzigen van een
                                                    bitwaarde van 1 naar 0 eenvoudig is, maar het wijzigen van 0 naar 1
                                                    is een veel langzamer proces waarbij een groot geheugenblok moet
                                                    worden veranderd naar <em> alleen </em> 1 bits en daarna moeten de
                                                    waardes waarvan je de bits niet wil veranderen herschreven worden.
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </p>
                                <p> Daarom zijn er verschillende soorten fysiek geheugens in de AVR-chips, maar niets
                                    daarvan verklaart de Harvard-architectuur volledig, waarin geheugen is verdeeld in
                                    <em> programma's </em> en <em> gegevens, </em> ongeacht hoe lang de gegevens moeten
                                    bestaan. De belangrijkste reden om twee verschillende
                                    geheugeninterfacecircuits te hebben, is dat het de processor toestaat
                                    tegelijkertijd een programma-instructie en een gegevenswaarde <em> te lezen.
                                    </em> Dit kan de processor in principe twee keer zo snel maken, hoewel niet
                                    veel snelheidswinst wordt gevonden in de praktijk.
                                </p>
                                <p> Om het voordeel van gelijktijdige instructie en het lezen van gegevens te begrijpen,
                                    moet je begrijpen dat processoren vaak zijn ontworpen met behulp van een idee
                                    genaamd <em> pipelining. </em> De standaard metafoor gaat over het doen van de was
                                    wanneer je meer dan één lading hebt. Je wast de eerste lading, terwijl je droger
                                    niets doet; dan was je <em> de tweede lading tijdens het drogen van de eerste
                                        lading, </em> enzovoort tot de laatste lading. Evenzo bevat de processor in een
                                    computer een circuit om een instructie te decoderen en een circuit om
                                    te rekenen. Als de processor één ding tegelijk doet, doet het
                                    instructie-decodeercircuit of het rekencircuit op elk moment niets.
                                    Maar als je de volgende instructie kunt lezen terwijl je de vorige uitvoert, blijft
                                    de hele processor bezig.
                                </p>
                                <p> Dit was een lange verklaring, maar het is nog steeds enorm vereenvoudigd. Ten eerste
                                    is het mogelijk om pipelining ook in een von Neumann-architectuur te gebruiken. En
                                    daarbij, een <em> pure </em> Harvard-architectuur zou een computer niet
                                    toestaan om programma's te laden die de computer zelf uitvoert. In de praktijk
                                    worden dus verschillende compromissen gebruikt.
                                </p>
                            </div>

                        </div>

                        <p> Atmel heeft sindsdien een reeks van ARM-compatibele 32-bits processors geïntroduceerd en
                            Arduino heeft boards die die processor gebruiken, maar compatibel met de lay-out van de
                            connectoren aan de randen.
                        </p>
                        <p> Een ding heeft bijgedragen aan de populariteit van de Arduino bij hobbyisten is de
                            beschikbaarheid van <em> shields, </em>. Dit zijn extra printplaten die op de
                            zijrandconnectoren worden aangesloten en dezelfde connectoren aan hun bovenkant hebben.
                            Shields voegen functies toe aan het systeem. Voorbeelden zijn motorbesturingsshields,
                            Bluetooth-shields voor communicatie met mobiele telefoons, RFID-shields om die
                            productlabels te lezen die je in de verpakking van veel producten vindt, enzovoort. Zowel
                            het bedrijf Arduino als anderen verkopen shields.
                        </p>
                        <div class="sidenote">
                            <small>Een aantal Arduino-shields</small><br />
                            <small><small>Afbeelding van Wikimedia genruiker Marlon J. Manrique, CC-BY-SA
                                    2.0.</small></small>
                        </div>

                        <img class="indent" src="../../afb/h6/l1/p6-o8.jpg" width="250px" alt="Geen Afbeelding" />

                        <p> Een geheel andere hobbyarchitectuur is de <em> Raspberry Pi. </em> Het is ontworpen om te
                            worden gebruikt als een desktop- of laptopcomputer, maar met meer toegang tot de
                            elektronica. Het maakt gebruik van een ARM-compatibele processor, zoals de meeste mobiele
                            telefoons, maar in plaats van het uitvoeren van besturingssoftware voor telefoons zoals
                            Android, draait het "echte" computerbesturingssystemen. Het wordt geleverd met Linux, maar
                            mensen gebruiken het ook met Windows.
                        </p>
                        <p> Het belangrijkste dat het speciaal maakt, is dat het goedkoop is: verschillende modellen
                            variëren in prijs van $ 5 tot $ 35. Die prijs bevat alleen de printplaat, zoals op de
                            afbeelding, zonder een toetsenbord, display, muis, voedingsadapter of een hoes. De grootste
                            kostenpost in kitcomputers is het display, dus de Pi is ontworpen om op je tv aan te
                            sluiten. Je kunt kits kopen met een minimale behuizing, een toetsenbord en andere
                            belangrijke add-ons voor ongeveer $ 20. Je kunt ook luxe hoesjes kopen om het eruit te laten
                            zien als elke andere computer, met een display, voor honderden dollars.
                        </p>
                        <p> Omdat de Pi bedoeld is voor educatief gebruik, wordt deze geleverd met software, waarvan
                            sommige gratis is, maar waarvan sommige over het algemeen geld kost voor
                            niet-Pi-computers. Een belangrijk voorbeeld is Mathematica, dat meer dan $ 200 kost voor
                            studenten (hun goedkoopste prijs), maar gratis is inbegrepen op de Pi.
                        </p>
                        <p> Net als de Arduino ondersteunt de Pi add-on printplaten met dingen zoals sensoren en
                            draadloze communicatiemodules.
                        </p>
                        <div class="sidenote">
                            <small>Raspberry Pi board</small><br />
                            <small><small>Afbeelding van Evan Amos, via Wikimedia, publiek domein</small></small>
                        </div>
                        <img class="indent" src="../../afb/h6/l1/p6-o9.jpg" width="250px" alt="Geen Afbeelding" />
                    </div>
                </li>
            </ul>
        </div>
        <div class="endnote">
            <a href="#hint-architecture-general" data-toggle="collapse">
                Leer meer over computerarchitectuur in het algemeen.
            </a>
            <div id="hint-architecture-general" class="collapse">
                <h4> De Geheugenhiërarchie </h4>

                <p> Een gegeven van circuithardware is, <strong> hoe groter het geheugen, hoe langzamer het werkt.
                    </strong> om deze reden hebben computers niet alleen een grote hoop geheugen. Er zal een
                    klein aantal <em> registers </em> in de processor zelf zijn, meestal tussen de 8 en 16. De "grootte"
                    (aantal bits) van een gegevensregister is gelijk aan de breedte van de architectuur.
                </p>
                <p> Het hoofdgeheugen van de computer wordt tegenwoordig gemeten in GB (gigabytes of miljarden bytes).
                    Een geheugen van die omvang kan niet snel genoeg zijn om een moderne processor bij te houden.
                    Gelukkig hebben computerprogramma's over het algemeen <em> plaats van referentie </em>, wat betekent
                    dat als het programma net gebruik heeft gemaakt van een bepaalde geheugenlocatie, het waarschijnlijk
                    een nabijgelegen locatie hierna zal gebruiken. Dus een compleet programma kan heel groot zijn, maar
                    in de loop van een seconde zal er maar een klein deel van nodig zijn. Daarom zijn moderne computers
                    ontworpen met een of meer <em> cache </em> -geheugens - veel kleiner en daarom sneller - tussen de
                    processor en het hoofdgeheugen. De processor zorgt ervoor dat het meest recent gebruikte geheugen
                    naar de cache wordt gekopieerd.
                </p>
                <p> Een recente 64-bit x86-processor heeft een eerste niveau (L1) cache van 64 KB (duizenden bytes) in
                    de processorchip, een grotere maar langzamere L2-cache van 256 KB, ook in de processor, en een
                    L3-cache van maximaal 2 MB (megabytes, miljoenen bytes) buiten de processor. Elk niveau van cache
                    heeft een kopie van de meest recent gebruikte delen van het volgende niveau naar buiten: de L1-cache
                    kopieert een deel van de L2-cache, die een deel van de L3-cache kopieert, die een deel van het
                    hoofdgeheugen kopieert. Gegevens in de L1-cache zijn ongeveer even snel toegankelijk voor de
                    processor als de interne registers en elk niveau naar buiten is iets langzamer. Hardware in de
                    processor verwerkt al deze complexiteit, zodat programmeurs programma's kunnen schrijven alsof de
                    processor rechtstreeks op het hoofdgeheugen is aangesloten.
                </p>

                <h4>Second sourcing</h4>
                <p> Intel geeft licenties aan andere chipfabrikanten om processors te bouwen die dezelfde architectuur
                    gebruiken als de processors van Intel. Waarom doen ze dat? Zouden ze niet meer geld verdienen als
                    mensen alles bij Intel moesten kopen? De reden is dat computerfabrikanten, zoals Dell, Apple en
                    Lenovo, hun systemen niet zullen bouwen rond een architectuur die slechts bij één bedrijf
                    beschikbaar is.
                    Ze zijn niet bang dat Intel failliet gaat; de zorg is dat er mogelijk een groter dan verwachte vraag
                    is naar een bepaalde processor en dat Intel mogelijk niet in staat is bestellingen op tijd af te
                    handelen. Maar als die processor ook verkrijgbaar is bij andere bedrijven zoals AMD en Cyrix, dan
                    zal een vertraging bij Intel geen vertraging worden bij Dell. Die andere chipfabrikanten gebruiken
                    mogelijk niet dezelfde circuits als de Intel-versie, zolang ze zich maar hetzelfde gedragen op
                    architectuurniveau.
                </p>
            </div>
        </div>
        <div class="takeItFurther">
            <ol type="A">
                <li>
                    Voldoende leren over de Analytical Engine om zelfs een <em> eenvoudig </em> programma te kunnen
                    schrijven, is een behoorlijk grote onderneming. Maar als je geïnteresseerd bent, zijn hier
                    uitgebreide online bronnen beschikbaar:
                    <ul>
                        <li><a href="http://www.fourmilab.ch/babbage/contents.html" target="_blank">The Analytical
                                Engine Table of Contents (Engels) </a></li>
                        <li><a href="http://www.fourmilab.ch/babbage/emulator.html" target="_blank">Web Analytical
                                Engine Emulator (Engels) </a></li>
                    </ul>
                </li>
            </ol>
        </div>
    </div>
    <div class="full-bottom-bar" style="background-position: 20px 3px;">
        <div class="bottom-nav btn-group"> <a class="btn btn-default backbutton arrow" style="min-width: 90px;"
                href="H6L1P5.html">Terug</a> <a class="btn btn-default forwardbutton arrow" style="min-width:90px;"
                href="H6L1P7.html">Volgende</a> </div>
    </div>

</body>

</html>