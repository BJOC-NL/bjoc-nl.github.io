<!DOCTYPE html>
<html lang="nl">

<head>
    <link rel="icon" href="../../BJOC-NL-logo.png" type="image/png">
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="../../js+css/llab/loader.js"></script>
    <script type="text/javascript" src="../../js+css/gifffer.min.js"></script>
    <script type="text/javascript">
        window.onload = function () {
            Gifffer();
            Inhoudsopgave();
        }
    </script>
    <link rel="stylesheet" type="text/css" href="../../js+css/css/bjc-gifffer.css">
    <title>Hoofdstuk 5 Les 3: Tijdexperimenten, Pagina 3</title>
</head>

<body>
    <div class="full">
        <h2>Algoritmes classificeren</h2>
        <div class="learn">
            <p><strong>Op deze pagina</strong>, ga je leren dat sommige correcte algoritmes te langzaam zijn om goed
                kunnen
                gebruiken.
            </p>
        </div>
        <div class="forYouToDo" id="first">
            <ol>
                <li> Als hij nog niet open staat, open dat het project H5l3-timer van de vorige pagina. Je gaat
                    experimenteren met <code>time function</code> met de volgende invoerfuncties:
                    <ul>
                        <li><img src="../../afb/h3/l4/p2-b2.png" height="40" alt="Geen Afbeelding" />
                            (zoals je zag bij
                            <a href="../hoofdstuk-3/H3L4P2.html">
                                Hoofdstuk 3 Les 4: Een diagram-app maken</a>) </li>
                        <li>
                            <img src="../../afb/h5/l1/p3b3.png" height="40" alt="Geen Afbeelding" />
                            (zoals je zag bij
                            <a href="../hoofdstuk-5/H5L1P3.html">
                                Hoofdstuk 5 Les 1: Algoritmes om lijsten te verwerken</a>)</li>
                        <li>
                            <img class="" src="../../afb/h5/l3/p2b6.png" height="40" alt="Geen Afbeelding" />
                            (zoals je zag bij
                            <a href="../hoofdstuk-5/H5L3P1.html">
                                Hoofdstuk 5 Les 3: Algoritmes vergelijken</a>)</li>
                    </ul>
                    Wat gebeurt er voor elke invoer met de looptijd als je de grootte van de invoer verdubbelt?
                    <div class="endnote"> Wat betekent het om de grootte van de invoer voor
                        <code> getallen van () tot () </code> te verdubbelen?
                    </div>
                </li>
            </ol>
        </div>
        <p>Je kan algoritmen classificeren op basis van de tijd die ze nodig hebben om te worden uitgevoerd.</p>
        <div class="forYouToDo">
            <ol start="2">
                <li> <a class="run"
                        href="https://snap.berkeley.edu/snapsource/snap.html#present:Username=cfkaligula&ProjectName=H5L3-lijstvan"
                        target="_blank">
                        <img class="inline" src="../../afb/icons/LaadEnSlaOp.png" alt="Geen Afbeelding"></a><br />
                    Gebruik het <img src="../../afb/h5/l3/p3b1.png" height="40" alt="Geen Afbeelding" /> blok om de
                    volgende
                    twee blokken in Snap <em>! </em> te bouwen. Bepaal vervolgens welk algoritme binnen een
                    redelijke tijd kan worden uitgevoerd en welke niet. <div class="sidenote"> De lijst met 2-cijferige
                        nummers gaat van 10 tot 99. Er is een wiskundeblok dat je machten van 10 kan geven. </div>
                    <ol>
                        <li><img src="../../afb/h5/l3/p3b2.png" height="40" alt="Geen Afbeelding" /></li>
                        <li><img src="../../afb/h5/l3/p3b3.png" height="40" alt="Geen Afbeelding" /></li>
                    </ol>
                </li>
            </ol>
        </div>
        <p> Om een algoritme te classificeren, kijk je naar het aantal stappen dat nodig is om het algoritme te
            voltooien,
            vergeleken met de grootte van de invoer.<ul>
                <li> <strong> Redelijke tijd: </strong> als het aantal stappen kleiner is dan of gelijk aan een macht
                    van
                    de grootte van de invoer, wordt het algoritme uitgevoerd in <em> polynomiale tijd </em>. <p>
                        <em> Polynomiale tijd </em> omvat constante (<em> n </em> <sup> 0 </sup>), sublinear, lineair
                        (<em> n </em> <sup> 1 </sup>), kwadratische (<em> n </em> <sup> 2 </sup>), kubieke (<em> n </em>
                        <sup> 3 </sup>), enz. functies:
                        <table class="bordered" summary="list of several reasonable time efficiencies">
                            <tr>
                                <th scope="col" style="width:20%;">algoritme-efficiëntie</th>
                                <th scope="col" style="width:40%;">Als je de grootte van de invoer
                                    verdubbeld,,<br />dan...
                                </th>
                                <th scope="col" style="width:40%;">voorbeeld-algoritme</th>
                            </tr>
                            <tr>
                                <td>constant</td>
                                <td>blijft de tijd hetzelfde (vermenigvuldigt met 2<sup>0</sup> wat gelijk is aan 1)
                                </td>
                                <td><code>item (</code><var>87</var><code>) of ()</code></td>
                            </tr>
                            <tr>
                                <td>sublineair</td>
                                <td>vermenigvuldigt de tijd met een getal tussen de 1 en 2 (tussen 2<sup>0</sup> en
                                    2<sup>1</sup>)</td>
                                <td>binaire zoekopdracht: <code>positie van () in een gesorteerde lijst</code></td>
                            </tr>
                            <tr>
                                <td>lineair</td>
                                <td>vermenigvuldigt de tijd met 2 (wat 2<sup>1</sup> is)</td>
                                <td>lineair zoekopdracht: <code>positie of () in een ongesorteerde lijst</code></td>
                            </tr>
                            <tr>
                                <td>kwadratisch</td>
                                <td>vermenigvuldigt de tijd met 4 (wat 2<sup>2</sup> is)</td>
                                <td>sommige zoekalgoritmes</td>
                            </tr>
                            <tr>
                                <td>kubiek</td>
                                <td>vermenigvuldigt de tijd met 8 (wat 2<sup>3</sup> is)</td>
                                <td>sommige algoritmes om genen in kaar te brengen </td>
                            </tr>
                        </table>
                    </p>
                    <p> Het is zeldzaam om polynomiale algoritmes te vinden die meer dan kubieke (<em> n </em> <sup> 3
                        </sup>) tijd kosten.
                    </p>
                    <div class="endnote">
                        <p><a href="#hint-between-categories" data-toggle="collapse">
                                Wat als een algoritme een hoeveelheid tijd kost die <em> tussen </em> twee categorieën
                                valt?</a></p>
                        <div id="hint-between-categories" class="collapse">
                            Deze categorieën zeggen dat een algoritme <em> hoogstens </em> zoveel tijd kost. Dus een
                            algoritme voor constante tijd is dus ook een algoritme voor lineaire tijd, en ook een
                            algoritme
                            voor polynomiale tijd. Maar <em> meestal </em> als iemand zegt dat een algoritme
                            "kwadratische
                            tijd kost", bedoelen ze dat het <em> meer dan </em> lineaire tijd maar <em> niet meer dan
                            </em>
                            kwadratische tijd kost.</div>
                    </div>
                </li>
                <li> <strong> Onredelijke tijd: </strong> als het aantal stappen groter is dan enig macht van de grootte
                    van de invoer (dat wil zeggen, meer dan een polynomiale functie), dan werkt het algoritme in een
                    <em>
                        onredelijke </em> tijdshoeveelheid. <div class="endnote"> Het klassieke voorbeeld van een
                        algoritme
                        met <em> onredelijke tijd </em> is er een die <em> exponentiele </em> (2 <sup> <em> n </em>
                        </sup> ) <em> tijd </em> gebruikt. Gewoon <em> 1 </em> toevoegen aan ded invoergrootte (<em> n
                        </em>) <em> verdubbelt </em> het aantal stappen! </div>
                    <p> Een soort probleem waarvan de oplossing vaak onredelijk is, is een <em>
                            optimalisatie</em>probleem
                        (zoals "vind de beste" of "vind de kleinste").</p>
                </li>
            </ul>
        </p>
        <div class="takeNote">
            Het is belangrijk om te begrijpen dat een onredelijketijd-algoritme <strong> een probleem nog steeds correct
                oplost </strong>. Onredelijketijd-algoritmes kunnen soms worden vervangen door een <em> heuristiek
            </em>, dat is een polynomialetijd-algoritme dat het probleem niet precies oplost, maar een goede benadering
            biedt. </div>

        <p>
            Een reden waarom het de moeite waard is om deze categorieën te leren, is dat je bij het schrijven van
            programma's vaak een probleem moet oplossen waarvoor al oplossingen zijn bedacht. Je hebt bijvoorbeeld
            geleerd
            dat het zoeken naar iets in een ongeordende lijst lineaire tijd vergt, maar als de lijst is gesorteerd, kun
            je
            deze sneller doorzoeken (in sublineaire tijd). Dus als je een programma schrijft dat herhaaldelijk in een
            lijst
            moet zoeken, weet je dat het de moeite waard is om de lijst te sorteren voordat je gaat zoeken. Als je weet
            welke standaardalgoritmen er al zijn, kan je nieuwe algoritmen bouwen.
        </p>
        <div class="forYouToDo">
            <ol start="3">
                <li> Bekijk enkele algoritmen die je hebt gebouwd. Bepaal of elk algoritme in constante tijd, sublinear,
                    lineaire, kwadratische of onredelijke tijd loopt. </li>
            </ol>
        </div>
        <div class="ifTime">
            <ol start="4">
                <li> Voor de manier waarop Alex gehele getallen toevoegt, maak je een grafiek met het aantal gehele
                    getallen op de horizontale en de looptijd op de verticale as. Genereer gegevens voor het diagram
                    door
                    <code> time function </code> uit te voeren met grote invoeren voor <code> Alex' manier </code>
                    (bijvoorbeeld veelvouden van 100). Gebruik vervolgens de technieken van Les 2 om het diagram te
                    maken.
                </li>
                <li> Welke informatie vertelt dit diagram je over het algoritme van Alex? Kost het constante tijd,
                    lineaire
                    tijd, andere polynomiale tijd of is het onredelijke tijd?
                </li>
            </ol>
        </div>
        <div class="forYouToDo">
            <ol start="6">
                <li>
                    <div class="assessment-data" type="multiplechoice" identifier="Timing of database tasks"
                        hasinlinefeedback="true" maxchoices="1" responseIdentifier="ri1" shuffle="true">
                        <div class="prompt"> De onderstaande tabel toont de computertijd die nodig is om verschillende
                            taken op de gegevens van steden van verschillende grootte uit te voeren. <p>
                                <table class="bordered"
                                    summary="hours required for various data management tasks for towns of various sizes">
                                    <tr>
                                        <th scope="col">Taak</th>
                                        <th scope="col">Klein Dorp<br />(bevolking 1.000)</th>
                                        <th scope="col">Gemiddeld Dorp<br />(bevolking 10.000)</th>
                                        <th scope="col">Groot Dorp<br />(bevolking 100.000)</th>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Data Invoeren</th>
                                        <td>2 uren</td>
                                        <td>20 uren</td>
                                        <td>200 uren</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap"> Data Opslaan</th>
                                        <td>0,5 uur</td>
                                        <td>5 uren</td>
                                        <td>50 uren</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Data Doorzoeken</th>
                                        <td>5 uren</td>
                                        <td>15 uren</td>
                                        <td>25 uren</td>
                                    </tr>
                                    <tr>
                                        <th scope="row" style="white-space: nowrap">Data Sorteren</th>
                                        <td>0,01 uur</td>
                                        <td>1 uur</td>
                                        <td>100 uren</td>
                                    </tr>
                                </table>
                            </p>
                            Op basis van de informatie in de tabel, welke van de volgende taken neemt waarschijnlijk de
                            <em><strong> langste</strong> </em> hoeveelheid tijd in beslag wanneer deze wordt
                            opgeschaald voor een stad met 1.000.000 inwoners.
                        </div>
                        <div class="choice" identifier="c1">
                            <div class="text">Data Invoeren</div>
                            <div class="feedback"> Omdat de populatiegrootte wordt vermenigvuldigd met 10, wordt de
                                benodigde tijd voor het invoeren van gegevens ook vermenigvuldigd met 10, dus voor een
                                populatie van 1.000.000 zou dit ongeveer 10 * 200 = 2000 uur moeten duren. </div>
                        </div>
                        <div class="choice" identifier="c2">
                            <div class="text">Data Opslaan</div>
                            <div class="feedback"> Als de populatiegrootte met 10 wordt vermenigvuldigd, wordt de tijd
                                die nodig is om een back-up van gegevens te maken met 10 vermenigvuldigd, dus voor een
                                populatie van 1.000.000 zou dit ongeveer 10x50 = 500 uur moeten duren.
                            </div>
                        </div>
                        <div class="choice" identifier="c3">
                            <div class="text">Data Doorzoeken</div>
                            <div class="feedback"> Het doorzoeken van de gegevens lijkt te stijgen met ongeveer 10 uur
                                elke
                                keer dat de populatie wordt vermenigvuldigd met 10, dus voor een populatie van 1.000.000
                                zou het ongeveer 35 uur moeten duren . </div>
                        </div>
                        <div class="choice" identifier="c4">
                            <div class="text">Data Sorteren</div>
                            <div class="feedback"> Correct! Omdat de populatiegrootte wordt vermenigvuldigd met 10,
                                wordt de
                                benodigde tijd voor het sorteren van gegevens vermenigvuldigd met 100. Dus voor een
                                populatie van 1.000.000 ongeveer 100*100 = 10.000 uur. </div>
                        </div>
                        <div class="responseDeclaration" identifier="ri1">
                            <div class="correctResponse" identifier="c4"></div>
                        </div>
                    </div>
                </li>
                <li>Schrijf een stuk tekst waarin het verschil wordt uitgelegd tussen algoritmen die binnen een
                    redelijke
                    tijd worden uitgevoerd en algoritmen die onredelijke tijd vereisen om te worden uitgevoerd.</li>
            </ol>
        </div>
    </div>
    <div class="full-bottom-bar" style="background-position: 20px 3px;">
        <div class="bottom-nav btn-group"> <a class="btn btn-default backbutton arrow" style="min-width: 90px;"
                href="H5L3P2.html">Terug</a> <a class="btn btn-default forwardbutton arrow" style="min-width:90px;"
                href="H5L4P1.html">Volgende</a> </div>
    </div>
</body>

</html>